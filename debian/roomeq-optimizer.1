.TH ROOMEQ-OPTIMIZER 1 "August 2025" "roomeq 0.6.1" "Audio Processing"
.SH NAME
roomeq-optimizer \- High-performance Rust optimizer for room equalization

.SH SYNOPSIS
.B roomeq-optimizer
.RI [ OPTIONS ]

.SH DESCRIPTION
.B roomeq-optimizer
is a high-performance Rust implementation of the room equalization optimizer.
It processes optimization jobs from stdin in JSON format and outputs results
in either JSON or human-readable format.

This optimizer provides 10-20x faster processing compared to the Python
implementation while maintaining full algorithm compatibility.

.SH OPTIONS
.TP
.B \-\-progress
Output progress steps during optimization. Each step shows the current
filters, corrected response, and residual error. Without this flag,
only the final result is output.

.TP
.B \-\-human\-readable
Output human-readable text instead of JSON. This makes the output
suitable for interactive use but harder to parse programmatically.

.TP
.B \-\-frequency\-response
Output frequency response data after each filter step. This provides
detailed frequency-domain information for analysis and visualization.

.TP
.B \-\-usable\-range\-only
Only detect and output the usable frequency range, then exit. This is
useful for preprocessing measurements to determine optimization boundaries.
Requires only the measured_curve field in the input JSON.

.TP
.B \-h, \-\-help
Print help information and exit.

.TP
.B \-V, \-\-version
Print version information and exit.

.SH INPUT FORMAT
The optimizer reads a JSON optimization job from stdin with the following structure:

.nf
{
  "measured_curve": {
    "frequencies": [20, 100, 1000, 10000, 20000],
    "magnitudes_db": [-3, -1, 0, -2, -6]
  },
  "target_curve": {
    "name": "Harman",
    "description": "Harman target curve",
    "curve": [
      {"frequency": 20, "target_db": 0.0},
      {"frequency": 20000, "target_db": 0.0}
    ]
  },
  "optimizer_params": {
    "name": "Default",
    "qmax": 10,
    "maxdb": 6,
    "mindb": -6,
    "add_highpass": true,
    "acceptable_error": 1.0,
    "min_frequency": 50.0,
    "max_frequency": 8000.0
  },
  "sample_rate": 48000,
  "filter_count": 5
}
.fi

For usable range detection, only measured_curve is required:
.nf
{
  "measured_curve": {
    "frequencies": [20, 100, 1000, 10000, 20000],
    "magnitudes_db": [-3, -1, 0, -2, -6]
  }
}
.fi

.SH OUTPUT FORMATS
.SS JSON Output (default)
Without \-\-human\-readable, all output is JSON for easy parsing:

Progress steps (with \-\-progress):
.nf
{"type":"usable_frequency_range","frequency_range":{"low_hz":70.7,"high_hz":10000.0},"message":"Detected usable frequency range: 70.7 Hz - 10000.0 Hz"}
{"step":1,"filters":[...],"residual_error":2.5,"message":"Added filter 1 at 1000Hz","progress_percent":10.0}
.fi

Final result:
.nf
{"success":true,"filters":[...],"final_error":1.2,"original_error":3.8,"improvement_db":10.1,"processing_time_ms":150,"usable_freq_low":70.7,"usable_freq_high":10000.0}
.fi

Usable range only (with \-\-usable\-range\-only):
.nf
{"usable_freq_low":70.7,"usable_freq_high":10000.0,"frequency_candidates":26,"optimization_frequencies":19,"message":"Detected usable frequency range: 70.7 Hz - 10000.0 Hz"}
.fi

.SS Human-readable Output
With \-\-human\-readable, output is formatted for human consumption:

.nf
Usable frequency range: 70.7 Hz - 10000.0 Hz (26 frequency candidates)
Step 1: Added filter 1 at 1000Hz (3.2dB) (Error: 2.5 dB, Progress: 10.0%)
  Added: PEQ 1000Hz Q=2.0 Gain=3.2dB

=== OPTIMIZATION RESULTS ===
Success: true
Filters created: 5
Usable frequency range: 70.7 Hz - 10000.0 Hz
Original error: 3.80 dB RMS
Final error: 1.20 dB RMS
Improvement: 10.1 dB
Processing time: 150 ms

Filters:
  1: PEQ 1000Hz Q=2.0 Gain=3.2dB
  2: PEQ 2000Hz Q=1.5 Gain=-2.1dB
.fi

.SH EXAMPLES
.SS Basic optimization with JSON output
.nf
echo '{"measured_curve":...,"target_curve":...}' | roomeq-optimizer
.fi

.SS Interactive optimization with human-readable output
.nf
roomeq-optimizer --progress --human-readable < job.json
.fi

.SS Detect usable frequency range only
.nf
echo '{"measured_curve":{"frequencies":[...],"magnitudes_db":[...]}}' | roomeq-optimizer --usable-range-only
.fi

.SS Progress tracking with frequency response data
.nf
roomeq-optimizer --progress --frequency-response < job.json
.fi

.SS Override frequency range in optimization
.nf
echo '{"measured_curve":...,"optimizer_params":{"min_frequency":50,"max_frequency":8000,...}}' | roomeq-optimizer
.fi

.SH FREQUENCY RANGE DETECTION
The optimizer automatically detects the usable frequency range by analyzing
signal levels relative to the average. Frequencies with levels more than 8dB
below average are excluded from optimization.

Override the detected range using optimizer_params:
.IP \(bu 2
min_frequency: Force lower frequency limit
.IP \(bu 2
max_frequency: Force upper frequency limit

.SH EXIT STATUS
.TP
.B 0
Optimization completed successfully
.TP
.B 1
Error occurred (invalid input, optimization failure, etc.)

.SH SEE ALSO
.BR roomeq-server (1),
.BR rms-level (1)

For complete examples and Python integration, see /usr/share/doc/roomeq/rust/examples/

.SH AUTHOR
HiFiBerry <support@hifiberry.com>

.SH COPYRIGHT
Copyright (C) 2025 HiFiBerry. This is free software; see the source for
copying conditions.
